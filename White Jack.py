# -*- coding: utf-8 -*-
"""95_106_109.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aoSyASECM7xisXxOcHr04aQDqc-UXgbs
"""

import numpy as np
import secrets as sc
import random 
import itertools as IT

'''
implement picking new card after loss
implement algo 
implement grand_total and card_val() function

'''

class game:
  
  def __init__(self, N=13) -> None:
      self.initial_deck = [ _ for _ in range(1, N+1) ]
      self.initial_deck += self.initial_deck
      self.tmp_deck = self.initial_deck
      self.initial_deck = np.array(self.initial_deck)
      self.tmp_dec = np.array(self.tmp_deck)
      self.h_deck = np.array([])
      self.c_deck = np.array([])
  
  def print_deck(self):
      print(self.initial_deck)
      print(self.tmp_deck)
      print(np.size(self.tmp_deck))
      print(self.h_deck)
      print(self.c_deck)


  def shuffle(self):
      # ---------------------------------------------NOT ADJUSTED TO N ------------------------------------------------
      np.random.shuffle(self.tmp_deck)
      print(f"TMp deck {self.tmp_deck}")

      # can be implemented more realistically
      # take first 5 and store it in h deck next 5 in c deck
      self.h_deck = [self.tmp_deck[i] for i in range(5)]
      print(self.h_deck)
      self.tmp_deck = [ self.tmp_deck[i] for i in range(5,25+1)]
      print(f"TMp deck {self.tmp_deck}")
      
      self.c_deck = [self.tmp_deck[i] for i in range(5)]
      print(self.c_deck)
      self.tmp_deck = [ self.tmp_deck[i] for i in range(5,20+1)]
      print(f"TMp deck {self.tmp_deck}")

  def algo(self):
      # ---------------------------------- Algo goes in here -------------------------------
      return sc.choice(self.c_deck)


  def loser(self, h_card, c_card):
      # --------------------------------- who wins and loses ----------------------------
      if h_card<c_card : 
        return "human"
      elif h_card>c_card : 
        return "computer"
      else :
        return "draw"


  def cut(self, h_card, c_card):
      # --------------------------------- excluding played cards from deck -----------------------------------
      c1_done=0 
      c2_done=0
      for card1, card2 in IT.zip_longest(self.h_deck, self.c_deck, fillvalue="-100"):
        print(f" h {card1} - c {card2}")
        if card1 == h_card and not c1_done:
          self.h_deck.remove(card1)
          c1_done=1
          print(f"removed {h_card}")
        if card2 == c_card and not c2_done:
          self.c_deck.remove(card2)
          c2_done=1
          print(f"removed {c_card}")
        if c1_done and c2_done:
          return

  def card_val():
      pass

  def grand_total(self):
      print("Implement grand total")

      pass

  def winner(self, player):
      print(f"{player} HAS WON THE GAME!!!")

  def result(self):
      if not np.size(self.h_deck) and np.size(self.c_deck):
          self.winner("human")
      elif not np.size(self.c_deck) and np.size(self.h_deck):
          self.winner("computer")
      else :
          self.grand_total()

  def pick_card(self, player):
      # ------------------------------ Get card from top of deck ---------------------------------------
      pass

  def play(self):

      for i in range(15):
          h_card = sc.choice(self.h_deck)
          c_card = self.algo()
          print(f" h card {h_card} vs c card {c_card}")

          #cut these out of their decks
          self.cut(h_card, c_card)
          

    
          loser = self.loser(h_card, c_card)

          if loser == "human" : 
              self.pick_card("human")
              print("Computer won")
          elif loser == "computer":
              self.pick_card("computer")
              print("Human won")
          else :
              print("Draw")

          # is anyone's hand empty
          if not np.size(self.h_deck) or not np.size(self.c_deck) :
              print(f"someone's hand is empty")
              break
      
      self.result()

lord = game()
lord.shuffle()
print(lord.print_deck())

lord.play()

